# CUSNARKS Overview
CUSNARKS is an optimized CUDA implementation of ZK-SNARK setup and prover based on *Groth16* over curve BN128 XXX TODO Add link to curve XXX. It has been 
designed with the objective of computing proofs for up to 2^27 constraints in less than 10 minutes 
(we are not quite there though). CUSNARKS is expected to work with [circom][] for the generation and 
compilation of circuits, and with [snarkjs][] for the computation witnesses, proof verification and parts of the trusted setup.
Additionally, CUSNARKS works with [rust-circom][], an optimized version of [circom][] that allows to compile very large circuits.

Cusnarks has been developed in C/C++/CUDA-C and Python. Python is the driving language where proof and setup scripts are launched.
 Computation intensive functionality on the host side has been written in C/C++. Computation intensive functionality on the the device (GPU)
side has been writtedn in CUDA. Cython is used to build wrappers around C functions so that they can be called from Python.

Elliptic curve scalar multiplication and polynomial multiplication (via FFT), the heaviest functionality in terms of 
computation requirements, have been implemented to run on the GPU side.

Two libraries are generated :
1. *libcusnarks.so* : Cusnarks shared library
2. *pycusnarks.so* : Cusnarks shared library wrapped with Cython wrapper so that it can be used from Python

To launch CUSNARKS just make sure that your LD_LIBRARY_PATH includes cusnarks/lib directory.

## Outline
* [Installation][]
* [Launching Cusnarks](#Launching-Cusnarks)
* [File Formats][]
* [Architecture][]
* [Modules][]
* [Some Results][]
* [Other Info](#Other-Info)
  
## Installation
1. Download repository www.github.com/iden3/cusnarks.git. From now on, the folder where cusnarks is downloaded will be called $CUSNARKS_HOME

2. Ensure that all [dependencies][] are installed. 
    - Python3.6+
        - Cython (0.26.1)
        - numpy (1.16.4)
        - future (0.17.1)
        - nvgpu (0.8.0)
    - g++ compiler
    - nvcc compiler (Optional)
    - openmp
    - nodejs
    - Rust compiler

3. Add $CUSNARKS_HOME/lib to LD_LIBRARY_PATH

```sh
export LD_LIBRARY_PATH=$CUSNARKS_HOME/lib:$LD_LIBRARY_PATH
```

4. Build Cusnarks to generate shared libraries in $CUSNARKS_HOME/lib.

```sh
make all
```

5. Generate some metadata required for CUSNARKS, including :
- Roots of unity for curve BN128 xxx TODO Add link to curve description XXX. default option generates 2^20, which allows processing circuits of 
up to 2^19 contraints. When prompted, provide the desired number of roots to generate (maximum is 2^28).
- Location of folder to place input/output data. By default, location is $CUSNARKS_HOME/circuits

```shmake config
```

6. Launch units tests (optional) -> Currently, not working, but don't worry. Bugs are in the test :-))

```sh
make test
```

## Launching Cusnarks
Launch setup and proof generation by running pysnarks.py. 

```sh
cd src/python
python3 pysnarks.py -h
```

To generate a trusted setup from a .json/.bin compiled circuit, type:

```sh
CUDA_DEVICE_LIST=<ordered list of GPUs> python3 pysnarks.py -m s -in_c <INPUT_CIRCUIT file> -pk <OUT_PROVING_KEY file> -vk <OUT_VERIFICATION_KEY file> -seed <RANDOM SEED> 
```

Mandatory arguments:
- INPUT_CIRCUIT file : location of file containing set of constraints generated by compiler. input file is expected to be in Extenion needs to be .json, .bin or .r1cs. 
   Desription of the formats will be provided later. XXX TODO : Add link XXX
- OUT_PROVING_KEY file : Output Proving Key file generated during trusted setup. Extension needs to be .json or .bin. Description of the file formats will be provided later XXXX TODO : Add link XXXX
- OUT_VERIFICATION_KEY file : Output Verification Key file generated by trusted setup. Extension needs to be .json. Description of the file format will be prrovided later XXX TODO : Add Link XXX

As a general rule for providing input/output file names, if input or output files are places in the location preconfigured  during step [5] XXX TODO Add link XXX, just provide file name. CUSNARKS wil automatically search
in this directory

Running the trusted setup requires [snarkjs][] being installed to compute parts of the verification key. CUSNARKS automatically downloads it into $CUSNARKS_HOME/third_party_libs/snarkjs

There are two mechanisms to generate a proof:
- Server mode : Launches a server that accepts requests to generate proofs for a given trusted setup by providing a witness file. This is the default and recommended mechanism (Prover initialization is slow)
- One off : Launches a single Prover


To launch Proof Server:
```sh
CUDA_DEVICE_LIST=<ordered list of GPUs> python3 pysnarks.py -m -pk <INPUT_PROVING_KEY file> 
```

Mandatory arguments:
- INPUT_PROVING_KEY file : Input Proving Key file generated by trusted setup. Extension needs to be .json or .bin. Description of the file formats will be provided later XXXX TODO : Add link XXXX

To request a proof: 

```sh
CUDA_DEVICE_LIST=<ordered list of GPUs> python3 pysnarks.py -m -vk <INPUT_VERIFICATION_KEY file> -w <INPUT_WITNESS file file> -p <OUTPUT_PROOF file> -pd <OUTPUT_PUBLIC_DATA file> -seed <RANDOM SEED> -v <0|1>
```
Mandatory arguments:
- INPUT_WITNESS file : Input Witness file. Extension needs to be .bin or .dat.  Description of the file format will be prrovided later XXX TODO : Add Link XXX
- OUTPU_PROOF file :   Output file containing proof. Extension needs to be .json.  Description of the file format will be prrovided later XXX TODO : Add Link XXX
- OUTPU_PUBLIC_DATA file : OUtput file containing public data. Extension needs to be .json. Description of the file format will be prrovided later XXX TODO : Add Link XXX

Optional arguments
- -v : Enable verification. If value is 1, proof verification is enabled. After proof is generated, CUSNARKS will call [snarkjs][] to verifty proof. CUSNARKS will return the output 
- INPUT_VERIFICATION_KEY file: If verification is required, location of verification file generated during trusted setup needs to be provided. Extension is .json. XXX Add link XXX

To request a proof in non server mode (assumes server is not launched. If it has been launched, it will run on Server Mode):

```sh
CUDA_DEVICE_LIST=<ordered list of GPUs> python3 pysnarks.py -m -pk<INPUT_PROVING_KEY file> -vk <INPUT_VERIFICATION_KEY file> -w <INPUT_WITNESS file file> -p <OUTPUT_PROOF file> -pd <OUTPUT_PUBLIC_DATA file> -seed <RANDOM SEED> -v <0|1>
```

## File Formats
CUSNARKs requires and generates different files. The picture below XXX TODO Add reference to picture XXX shows a block diagram containing the three main actors (Setup, Proof Server and Prover) and how they relate to the 
different files. In this section we will describe the different files and their formats

XXX TODO Add Table XXXX

File type   | Extensions
Constraints | .bin, .json, .rics
Proving Key | .json, .bin
Verification Key | .json
Witness | .txt, .json, .dat, .bin
Rpoof | .json
Public Data | .json
Results |


![File Formats](doc/block.png)

### Constraints
Constraint files are generated by a SNARK compiler and consumed by CUSNARKS trusted setup.

#### .json
Constraint system generated by [circom][]

#### .bin
Constraint system generated by [rust-circom][]

#### .r1cs
Constraint system generated by [circom][]. See https://hackmd.io/3epPqH4tSYqZbph2R9C5Mw for a detailed description.

### Proving Key

#### .json


#### .bin

### Verification Key

#### .json

### Witness

#### .txt

#### .json

#### .bin


#### .data

### Proof

#### .json

### Public Data


#### .json

### Results

## Architecture

Modules are divided into 4 categories depending on functionality:

1. **Infrastructure Layer** : Modules in this class have no dependencies and perform basic functionality common to all project (constants and type defitiontion).  Infrastructure modules can be accessed by both host and device.

2. **Service Layer** : Modules in this class Implement non core functionality used by higher layerts (logging, random number generation or CUDA kernel launch abstraction). Service modules are implemented in C or CUDA C. All services layer modules are accessible by host side. Logging can be access by both host and device.

3. **Core Layer**  ; Modules in this category implement Snarks core functionalty,  including modular and elliptic curve implementation. Core functionality is duplicated in C and Python. Python was used as a fast prototyping implementation that could be used to validate C version, and not as an efficient Snarks implementation. C counter part on the other hand was designed with the main objective of being a very efficient implementation in terms of execution time. Thus, most modules are executed in the device side. Host side C core layemodules are mainly used to define kernel function handlers.

4. **Applications Layer** : User applications. For now only prover functionality is included, but in the future witness generation and trusted setup implemention will be in this layer. Application layer modules are implemented in Python and can launch CUDA kernels via cusnarks_kernel module and host side accelerated C functions via utils_host Cython wrapped module

![Architecture](doc/architecture.png)


## Some Results

## Other Info
### Directory Structure
* *build\*    : Object files
* data\     : Auxiliary files (test circuits, precomputed roots of unity,...)
* lib\      : Generated dynamic libraries
* src\
  - cuda\     : C/C++/CUDA sources (.cpp, .c, .cu, .h)
  - cython\   : Cython files (.pyx, .pxd)
  - python\   : Python source files (.py)
* test\
  - python\   : Python unit test. They mainly test Python library using [unittest][] unit testing framework. 
   However, there are some files (*xxx_cu_xxx.py*) that test CUDA functions as well.
  - c\        : C unit tests for host side functionality.
  - ideas\    : Folder containing small scripts testing some ideas to be implmented in main code
* profiling\ : Profiling information
   python\   : Collection of scripts to measure time of CUDA functions 
* third_party_libs \ : Exteral libraries used will be automatically downloaded here
  - pcg-cpp  : implementation of PCG family of random number generators. Full details can be found at the [PCG-Random website].

### Requirements 
* python (Tested with Python 2.7)
  - numpy
* cython : Cython used to build wrappers of C++/CUDA functions callable from Python modules
* c++/gcc
* CUDA toolkit

[dependencies]: #Requirements 
[snarkjs]: https://www.github.com/iden3/snarkjs
[circom]: https://www.github.com/iden3/circom
[rust-circom]:https://www.github.com/adria0/rust-circom-experimental
[PCG-Random website]: http://www.pcg-random.org
[unittest]: https://python.org/3/library/unittest.html
[Architecture]: #Architecture
[Modules]: #Modules
[Installation]: #Installation
[Using Cusnarks]: #Using-Cusnarks
[Other Info]: #Other
[File Formats]: ##File-Formats


